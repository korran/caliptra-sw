// Licensed under the Apache-2.0 license.

use std::collections::HashMap;
use std::fmt::Write;
use std::path::PathBuf;
use std::process::Stdio;
use std::rc::Rc;
use std::{error::Error, path::Path, process::Command};

use caliptra_systemrdl::InstanceRef;
use quote::__private::TokenStream;
use quote::{format_ident, quote};
use ureg_schema::{Enum, EnumVariant, Register, RegisterBlock, RegisterBlockInstance};

static HEADER: &str = r"// Licensed under the Apache-2.0 license.
//
// Generated by hw-latest/fpga-sync/registers/gen.sh
";

static HEADER_SUFFIX: &str = r"
*/
";

static RDL_FILES: &[&str] = &[
    "caliptra_fpga_sync_regs.rdl",
];

fn run_cmd_stdout(cmd: &mut Command, input: Option<&[u8]>) -> Result<String, Box<dyn Error>> {
    cmd.stdin(Stdio::piped());
    cmd.stdout(Stdio::piped());

    let mut child = cmd.spawn()?;
    if let (Some(mut stdin), Some(input)) = (child.stdin.take(), input) {
        std::io::Write::write_all(&mut stdin, input)?;
    }
    let out = child.wait_with_output()?;
    if out.status.success() {
        Ok(String::from_utf8_lossy(&out.stdout).into())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?} stderr {}",
            cmd.get_program(),
            cmd.get_args(),
            out.status.code(),
            String::from_utf8_lossy(&out.stderr)
        )
        .into())
    }
}

fn remove_reg_prefixes(registers: &mut [Rc<Register>], prefix: &str) {
    for reg in registers.iter_mut() {
        if reg.name.to_ascii_lowercase().starts_with(prefix) {
            let reg = Rc::make_mut(reg);
            reg.name = reg.name[prefix.len()..].to_string();
        }
    }
}

fn rustfmt(code: &str) -> Result<String, Box<dyn Error>> {
    run_cmd_stdout(
        Command::new("rustfmt")
            .arg("--emit=stdout")
            .arg("--config=normalize_comments=true,normalize_doc_attributes=true"),
        Some(code.as_bytes()),
    )
}

fn write_file(dest_file: &Path, contents: &str) -> Result<(), Box<dyn Error>> {
    println!("Writing to {dest_file:?}");
    std::fs::write(dest_file, contents)?;
    Ok(())
}

fn real_main() -> Result<(), Box<dyn Error>> {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 3 {
        Err("Usage: codegen <rtl_dir> <dest_dir>")?;
    }

    let rtl_dir = Path::new(&args[1]);
    let rdl_files: Vec<PathBuf> = RDL_FILES
        .iter()
        .map(|p| rtl_dir.join(p))
        .filter(|p| p.exists())
        .collect();

    let dest_dir = Path::new(&args[args.len() - 1]);

    let file_source = caliptra_systemrdl::FsFileSource::new();
    let scope = caliptra_systemrdl::Scope::parse_root(&file_source, &rdl_files)
        .map_err(|s| s.to_string())?;
    let scope = scope.as_parent();

    let block = scope.lookup_typedef("caliptra_fpga_sync_regs").unwrap();
    let block = ureg_systemrdl::translate_block(InstanceRef{
        instance: &caliptra_systemrdl::Instance::default(),
        scope: block,
    })?;
    let block = block.validate_and_dedup()?;

    let tokens = ureg_codegen::generate_code(
        &block,
        ureg_codegen::Options {
            extern_types: Default::default(),
            module: quote! {},
        },
    );
    write_file(
        &dest_dir.join("lib.rs"),
        &rustfmt(&(HEADER.to_string() + &tokens.to_string()))?,
    )?;
    Ok(())
}

fn main() {
    if let Err(err) = real_main() {
        eprintln!("{}", err);
        std::process::exit(1);
    }
}
