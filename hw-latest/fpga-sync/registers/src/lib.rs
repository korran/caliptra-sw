// Licensed under the Apache-2.0 license.
//
// Generated by hw-latest/fpga-sync/registers/gen.sh

#![no_std]
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u64,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u64) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u64, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Read value: [`regs::ApbIn0ReadVal`]; Write value: [`regs::ApbIn0WriteVal`]
    #[inline(always)]
    pub fn apb_in0(&self) -> ureg::RegRef<crate::meta::ApbIn0, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::ApbIn1ReadVal`]; Write value: [`regs::ApbIn1WriteVal`]
    #[inline(always)]
    pub fn apb_in1(&self) -> ureg::RegRef<crate::meta::ApbIn1, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::ApbOutReadVal`]; Write value: [`regs::ApbOutWriteVal`]
    #[inline(always)]
    pub fn apb_out(&self) -> ureg::RegRef<crate::meta::ApbOut, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::JtagInReadVal`]; Write value: [`regs::JtagInWriteVal`]
    #[inline(always)]
    pub fn jtag_in(&self) -> ureg::RegRef<crate::meta::JtagIn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x18 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::JtagOutReadVal`]; Write value: [`regs::JtagOutWriteVal`]
    #[inline(always)]
    pub fn jtag_out(&self) -> ureg::RegRef<crate::meta::JtagOut, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u64`]; Write value: [`u64`]
    #[inline(always)]
    pub fn generic_input_wires(&self) -> ureg::RegRef<crate::meta::GenericInputWires, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u64`]; Write value: [`u64`]
    #[inline(always)]
    pub fn generic_output_wires(&self) -> ureg::RegRef<crate::meta::GenericOutputWires, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x30 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u64`]; Write value: [`u64`]
    #[inline(always)]
    pub fn cptra_obf_key(&self) -> ureg::Array<4, ureg::RegRef<crate::meta::CptraObfKey, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x38 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::ControlReadVal`]; Write value: [`regs::ControlWriteVal`]
    #[inline(always)]
    pub fn control(&self) -> ureg::RegRef<crate::meta::Control, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x58 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::StatusReadVal`]; Write value: [`regs::StatusWriteVal`]
    #[inline(always)]
    pub fn status(&self) -> ureg::RegRef<crate::meta::Status, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x60 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::TrngInReadVal`]; Write value: [`regs::TrngInWriteVal`]
    #[inline(always)]
    pub fn trng_in(&self) -> ureg::RegRef<crate::meta::TrngIn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x68 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::TrngOutReadVal`]; Write value: [`regs::TrngOutWriteVal`]
    #[inline(always)]
    pub fn trng_out(&self) -> ureg::RegRef<crate::meta::TrngOut, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x70 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`regs::ClockControlReadVal`]; Write value: [`regs::ClockControlWriteVal`]
    #[inline(always)]
    pub fn clock_control(&self) -> ureg::RegRef<crate::meta::ClockControl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x78 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u64`]; Write value: [`u64`]
    #[inline(always)]
    pub fn counter(&self) -> ureg::RegRef<crate::meta::Counter, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u64>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy)]
    pub struct ApbIn0ReadVal(u64);
    impl ApbIn0ReadVal {
        ///
        #[inline(always)]
        pub fn pdata(&self) -> u64 {
            (self.0 >> 0) & 0xffffffff
        }
        ///
        #[inline(always)]
        pub fn paddr(&self) -> u64 {
            (self.0 >> 32) & 0xffffffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ApbIn0WriteVal {
            ApbIn0WriteVal(self.0)
        }
    }
    impl From<u64> for ApbIn0ReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ApbIn0ReadVal> for u64 {
        #[inline(always)]
        fn from(val: ApbIn0ReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ApbIn0WriteVal(u64);
    impl ApbIn0WriteVal {
        ///
        #[inline(always)]
        pub fn pdata(self, val: u64) -> Self {
            Self((self.0 & !(0xffffffff << 0)) | ((val & 0xffffffff) << 0))
        }
        ///
        #[inline(always)]
        pub fn paddr(self, val: u64) -> Self {
            Self((self.0 & !(0xffffffff << 32)) | ((val & 0xffffffff) << 32))
        }
    }
    impl From<u64> for ApbIn0WriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ApbIn0WriteVal> for u64 {
        #[inline(always)]
        fn from(val: ApbIn0WriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ApbIn1ReadVal(u64);
    impl ApbIn1ReadVal {
        ///
        #[inline(always)]
        pub fn psel(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn penable(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn pwrite(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn pprot(&self) -> u64 {
            (self.0 >> 3) & 7
        }
        ///
        #[inline(always)]
        pub fn pauser(&self) -> u64 {
            (self.0 >> 32) & 0xffffffff
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ApbIn1WriteVal {
            ApbIn1WriteVal(self.0)
        }
    }
    impl From<u64> for ApbIn1ReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ApbIn1ReadVal> for u64 {
        #[inline(always)]
        fn from(val: ApbIn1ReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ApbIn1WriteVal(u64);
    impl ApbIn1WriteVal {
        ///
        #[inline(always)]
        pub fn psel(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u64::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn penable(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u64::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn pwrite(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u64::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn pprot(self, val: u64) -> Self {
            Self((self.0 & !(7 << 3)) | ((val & 7) << 3))
        }
        ///
        #[inline(always)]
        pub fn pauser(self, val: u64) -> Self {
            Self((self.0 & !(0xffffffff << 32)) | ((val & 0xffffffff) << 32))
        }
    }
    impl From<u64> for ApbIn1WriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ApbIn1WriteVal> for u64 {
        #[inline(always)]
        fn from(val: ApbIn1WriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ApbOutReadVal(u64);
    impl ApbOutReadVal {
        ///
        #[inline(always)]
        pub fn pdata(&self) -> u64 {
            (self.0 >> 0) & 0xffffffff
        }
        ///
        #[inline(always)]
        pub fn pready(&self) -> bool {
            ((self.0 >> 32) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn pslverr(&self) -> bool {
            ((self.0 >> 33) & 1) != 0
        }
    }
    impl From<u64> for ApbOutReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ApbOutReadVal> for u64 {
        #[inline(always)]
        fn from(val: ApbOutReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClockControlReadVal(u64);
    impl ClockControlReadVal {
        ///
        #[inline(always)]
        pub fn cycle_count(&self) -> u64 {
            (self.0 >> 0) & 0xffffffff
        }
        ///
        #[inline(always)]
        pub fn go(&self) -> bool {
            ((self.0 >> 32) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ClockControlWriteVal {
            ClockControlWriteVal(self.0)
        }
    }
    impl From<u64> for ClockControlReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ClockControlReadVal> for u64 {
        #[inline(always)]
        fn from(val: ClockControlReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ClockControlWriteVal(u64);
    impl ClockControlWriteVal {
        ///
        #[inline(always)]
        pub fn cycle_count(self, val: u64) -> Self {
            Self((self.0 & !(0xffffffff << 0)) | ((val & 0xffffffff) << 0))
        }
        ///
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1 << 32)) | (u64::from(val) << 32))
        }
    }
    impl From<u64> for ClockControlWriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ClockControlWriteVal> for u64 {
        #[inline(always)]
        fn from(val: ClockControlWriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlReadVal(u64);
    impl ControlReadVal {
        ///
        #[inline(always)]
        pub fn cptra_pwrgood(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn cptra_rst_b(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ss_debug_locked(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ss_device_lifecycle(&self) -> u64 {
            (self.0 >> 3) & 3
        }
        ///
        #[inline(always)]
        pub fn scan_mode(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn bootfsm_brkpoint(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ControlWriteVal {
            ControlWriteVal(self.0)
        }
    }
    impl From<u64> for ControlReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ControlReadVal> for u64 {
        #[inline(always)]
        fn from(val: ControlReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct ControlWriteVal(u64);
    impl ControlWriteVal {
        ///
        #[inline(always)]
        pub fn cptra_pwrgood(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u64::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn cptra_rst_b(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u64::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn ss_debug_locked(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u64::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn ss_device_lifecycle(self, val: u64) -> Self {
            Self((self.0 & !(3 << 3)) | ((val & 3) << 3))
        }
        ///
        #[inline(always)]
        pub fn scan_mode(self, val: bool) -> Self {
            Self((self.0 & !(1 << 5)) | (u64::from(val) << 5))
        }
        ///
        #[inline(always)]
        pub fn bootfsm_brkpoint(self, val: bool) -> Self {
            Self((self.0 & !(1 << 6)) | (u64::from(val) << 6))
        }
    }
    impl From<u64> for ControlWriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<ControlWriteVal> for u64 {
        #[inline(always)]
        fn from(val: ControlWriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct JtagInReadVal(u64);
    impl JtagInReadVal {
        ///
        #[inline(always)]
        pub fn tck(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn tms(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn tdi(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn trst_n(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> JtagInWriteVal {
            JtagInWriteVal(self.0)
        }
    }
    impl From<u64> for JtagInReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<JtagInReadVal> for u64 {
        #[inline(always)]
        fn from(val: JtagInReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct JtagInWriteVal(u64);
    impl JtagInWriteVal {
        ///
        #[inline(always)]
        pub fn tck(self, val: bool) -> Self {
            Self((self.0 & !(1 << 0)) | (u64::from(val) << 0))
        }
        ///
        #[inline(always)]
        pub fn tms(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u64::from(val) << 1))
        }
        ///
        #[inline(always)]
        pub fn tdi(self, val: bool) -> Self {
            Self((self.0 & !(1 << 2)) | (u64::from(val) << 2))
        }
        ///
        #[inline(always)]
        pub fn trst_n(self, val: bool) -> Self {
            Self((self.0 & !(1 << 3)) | (u64::from(val) << 3))
        }
    }
    impl From<u64> for JtagInWriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<JtagInWriteVal> for u64 {
        #[inline(always)]
        fn from(val: JtagInWriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct JtagOutReadVal(u64);
    impl JtagOutReadVal {
        ///
        #[inline(always)]
        pub fn tdo(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u64> for JtagOutReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<JtagOutReadVal> for u64 {
        #[inline(always)]
        fn from(val: JtagOutReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct StatusReadVal(u64);
    impl StatusReadVal {
        ///
        #[inline(always)]
        pub fn cptra_error_fatal(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn cptra_error_non_fatal(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ready_for_fuses(&self) -> bool {
            ((self.0 >> 2) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ready_for_fw_push(&self) -> bool {
            ((self.0 >> 3) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn ready_for_runtime(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mailbox_data_avail(&self) -> bool {
            ((self.0 >> 5) & 1) != 0
        }
        ///
        #[inline(always)]
        pub fn mailbox_flow_done(&self) -> bool {
            ((self.0 >> 6) & 1) != 0
        }
    }
    impl From<u64> for StatusReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<StatusReadVal> for u64 {
        #[inline(always)]
        fn from(val: StatusReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TrngInReadVal(u64);
    impl TrngInReadVal {
        ///
        #[inline(always)]
        pub fn itrng_data(&self) -> u64 {
            (self.0 >> 0) & 0xf
        }
        ///
        #[inline(always)]
        pub fn itrng_valid(&self) -> bool {
            ((self.0 >> 4) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> TrngInWriteVal {
            TrngInWriteVal(self.0)
        }
    }
    impl From<u64> for TrngInReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<TrngInReadVal> for u64 {
        #[inline(always)]
        fn from(val: TrngInReadVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TrngInWriteVal(u64);
    impl TrngInWriteVal {
        ///
        #[inline(always)]
        pub fn itrng_data(self, val: u64) -> Self {
            Self((self.0 & !(0xf << 0)) | ((val & 0xf) << 0))
        }
        ///
        #[inline(always)]
        pub fn itrng_valid(self, val: bool) -> Self {
            Self((self.0 & !(1 << 4)) | (u64::from(val) << 4))
        }
    }
    impl From<u64> for TrngInWriteVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<TrngInWriteVal> for u64 {
        #[inline(always)]
        fn from(val: TrngInWriteVal) -> u64 {
            val.0
        }
    }
    #[derive(Clone, Copy)]
    pub struct TrngOutReadVal(u64);
    impl TrngOutReadVal {
        ///
        #[inline(always)]
        pub fn etrng_req(&self) -> bool {
            ((self.0 >> 0) & 1) != 0
        }
    }
    impl From<u64> for TrngOutReadVal {
        #[inline(always)]
        fn from(val: u64) -> Self {
            Self(val)
        }
    }
    impl From<TrngOutReadVal> for u64 {
        #[inline(always)]
        fn from(val: TrngOutReadVal) -> u64 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    #[derive(Clone, Copy)]
    pub struct ApbIn0();
    impl ureg::RegType for ApbIn0 {
        type Raw = u64;
    }
    impl ureg::ReadableReg for ApbIn0 {
        type ReadVal = crate::regs::ApbIn0ReadVal;
    }
    impl ureg::WritableReg for ApbIn0 {
        type WriteVal = crate::regs::ApbIn0WriteVal;
    }
    impl ureg::ResettableReg for ApbIn0 {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct ApbIn1();
    impl ureg::RegType for ApbIn1 {
        type Raw = u64;
    }
    impl ureg::ReadableReg for ApbIn1 {
        type ReadVal = crate::regs::ApbIn1ReadVal;
    }
    impl ureg::WritableReg for ApbIn1 {
        type WriteVal = crate::regs::ApbIn1WriteVal;
    }
    impl ureg::ResettableReg for ApbIn1 {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct ApbOut();
    impl ureg::RegType for ApbOut {
        type Raw = u64;
    }
    impl ureg::ReadableReg for ApbOut {
        type ReadVal = crate::regs::ApbOutReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct JtagIn();
    impl ureg::RegType for JtagIn {
        type Raw = u64;
    }
    impl ureg::ReadableReg for JtagIn {
        type ReadVal = crate::regs::JtagInReadVal;
    }
    impl ureg::WritableReg for JtagIn {
        type WriteVal = crate::regs::JtagInWriteVal;
    }
    impl ureg::ResettableReg for JtagIn {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct JtagOut();
    impl ureg::RegType for JtagOut {
        type Raw = u64;
    }
    impl ureg::ReadableReg for JtagOut {
        type ReadVal = crate::regs::JtagOutReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct GenericInputWires();
    impl ureg::RegType for GenericInputWires {
        type Raw = u64;
    }
    impl ureg::ReadableReg for GenericInputWires {
        type ReadVal = u64;
    }
    impl ureg::WritableReg for GenericInputWires {
        type WriteVal = u64;
    }
    impl ureg::ResettableReg for GenericInputWires {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct GenericOutputWires();
    impl ureg::RegType for GenericOutputWires {
        type Raw = u64;
    }
    impl ureg::ReadableReg for GenericOutputWires {
        type ReadVal = u64;
    }
    #[derive(Clone, Copy)]
    pub struct CptraObfKey();
    impl ureg::RegType for CptraObfKey {
        type Raw = u64;
    }
    impl ureg::ReadableReg for CptraObfKey {
        type ReadVal = u64;
    }
    impl ureg::WritableReg for CptraObfKey {
        type WriteVal = u64;
    }
    impl ureg::ResettableReg for CptraObfKey {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Control();
    impl ureg::RegType for Control {
        type Raw = u64;
    }
    impl ureg::ReadableReg for Control {
        type ReadVal = crate::regs::ControlReadVal;
    }
    impl ureg::WritableReg for Control {
        type WriteVal = crate::regs::ControlWriteVal;
    }
    impl ureg::ResettableReg for Control {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Status();
    impl ureg::RegType for Status {
        type Raw = u64;
    }
    impl ureg::ReadableReg for Status {
        type ReadVal = crate::regs::StatusReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct TrngIn();
    impl ureg::RegType for TrngIn {
        type Raw = u64;
    }
    impl ureg::ReadableReg for TrngIn {
        type ReadVal = crate::regs::TrngInReadVal;
    }
    impl ureg::WritableReg for TrngIn {
        type WriteVal = crate::regs::TrngInWriteVal;
    }
    impl ureg::ResettableReg for TrngIn {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct TrngOut();
    impl ureg::RegType for TrngOut {
        type Raw = u64;
    }
    impl ureg::ReadableReg for TrngOut {
        type ReadVal = crate::regs::TrngOutReadVal;
    }
    #[derive(Clone, Copy)]
    pub struct ClockControl();
    impl ureg::RegType for ClockControl {
        type Raw = u64;
    }
    impl ureg::ReadableReg for ClockControl {
        type ReadVal = crate::regs::ClockControlReadVal;
    }
    impl ureg::WritableReg for ClockControl {
        type WriteVal = crate::regs::ClockControlWriteVal;
    }
    impl ureg::ResettableReg for ClockControl {
        const RESET_VAL: Self::Raw = 0;
    }
    #[derive(Clone, Copy)]
    pub struct Counter();
    impl ureg::RegType for Counter {
        type Raw = u64;
    }
    impl ureg::ReadableReg for Counter {
        type ReadVal = u64;
    }
}
